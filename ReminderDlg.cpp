// ReminderDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Calibration.h"
#include "ReminderDlg.h"
#include "afxdialogex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// CReminderDlg dialog

IMPLEMENT_DYNAMIC(CReminderDlg, CDialog)

CReminderDlg::CReminderDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CReminderDlg::IDD, pParent)
{

}

CReminderDlg::~CReminderDlg()
{
}

void CReminderDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}


LRESULT   __stdcall   CBTHookProc(long   nCode, WPARAM   wParam, LPARAM   lParam);
extern HHOOK   hHook;

BEGIN_MESSAGE_MAP(CReminderDlg, CDialog)
END_MESSAGE_MAP()


// CReminderDlg message handlers
// ReminderDlg message handlers
void CReminderDlg::OnOK()
{
	// TODO: Add extra validation here

	CDialog::OnOK();
}

void CReminderDlg::OnCancel()
{
	// TODO: Add extra cleanup here

	CDialog::OnCancel();
}

int __stdcall SetChildFont(struct HWND__ *, long);
extern CFont *g_Font;

BOOL CReminderDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO: Add extra initialization here
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();

	LOGFONT lf;                        // Used to create the CFont.
	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.
	lf.lfHeight = 15;                  // Request a 20-pixel-high font
	strcpy(lf.lfFaceName, "Times New Roman");
	if (g_Font.m_hObject)
		g_Font.DeleteObject();
	g_Font.CreateFontIndirect(&lf);    // Create the font.




	try
	{
		HRESULT hr = m_pAppConn.CreateInstance(__uuidof(Connection));
		if (FAILED(hr))
			AfxMessageBox("Can't create an intance of ADO.Connection");

		if (FAILED(m_pAppConn->Open(_bstr_t("File Name=MyData.udl"), _bstr_t(""), _bstr_t(""), adModeUnknown)))
			::AfxMessageBox(TEXT("Can't open datasource"));
		//m_pAppConn->Close();
	}
	catch (_com_error &e)
	{
		::AfxMessageBox(TEXT("I am in catch block 4"));
		_bstr_t bstrSource(e.Source());
		_bstr_t bstrDescription(e.Description());
		TRACE("Exception thrown for classes generated by #import");
		TRACE("\tCode = %08lx\n", e.Error());
		TRACE("\tCode meaning = %s\n", e.ErrorMessage());
		TRACE("\tSource = %s\n", (LPCTSTR)bstrSource);
		TRACE("\tDescription = %s\n", (LPCTSTR)bstrDescription);
	}
	catch (...)
	{
		TRACE("*** Unhandled Exception ***");
	}

	CString sql;
	sql.Format("USE settings");
	m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);

	sql.Format("select measurement_units from Common_settings");
	m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
	_variant_t var = m_recordset->GetCollect("measurement_units");
	CString cstr = (char *)_bstr_t(var);
	sscanf(cstr, "%d", &gyz);
	sql.Format("SELECT netword_IDN FROM Independent_settings");
	CString element;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		if (!m_recordset->adoEOF)
		{
			m_recordset->MoveFirst();
		}
		else
		{
			if (app->language == 0)
			{
				AfxMessageBox("没有发现表!");
			}
			else
			{
				hHook = SetWindowsHookEx(WH_CBT, (HOOKPROC)CBTHookProc, AfxGetInstanceHandle(), NULL);
				AfxMessageBox("Found no meter!");
			}
		}
		if (!m_recordset->adoEOF)
		{
			_variant_t var = m_recordset->GetCollect("netword_IDN");
			CString cstr = (char *)_bstr_t(var);
			element = cstr;
		}
	}
	catch (_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}

	this->SetWindowText("ReminderWindow");

	//calculateSpacing();
	//getM23(element);
	//
	//getM24(element);

	try
	{
		calculateSpacing();
	}
	catch (_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
		TRACE("Exception thrown when calculateSpacing ...");

	}
	catch (...)
	{
		TRACE("*** Unhandled Exception ***");
		TRACE("Exception thrown when calculateSpacing ....");
	}

	try
	{
		getM23(element);
	}
	catch (_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
		TRACE("Exception thrown when getM23 ...");

	}
	catch (...)
	{
		TRACE("*** Unhandled Exception ***");
		TRACE("Exception thrown when getM23 ....");
	}

	try
	{
		getM24(element);
	}
	catch (_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
		TRACE("Exception thrown when getM24 ...");

	}
	catch (...)
	{
		TRACE("*** Unhandled Exception ***");
		TRACE("Exception thrown when getM24 ....");
	}


	GetDlgItem(IDC_STATIC_MSG01)->SetWindowText("Please install the transducers now using the following parameters:");
	GetDlgItem(IDC_STATIC3)->SetWindowText("Transducer Type = " + transType);
	GetDlgItem(IDC_STATIC4)->SetWindowText("Transducer Spacing = " + tranSpace);
	GetDlgItem(IDC_STATIC5)->SetWindowText("Mounting Type = " + mountType);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}// ReminderDlg.cpp : implementation file
//

void CReminderDlg::getM23(CString meter_no){

	CString sql;
	sql.Format("select transducer_type from Independent_settings where netword_IDN = %s", meter_no);
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("transducer_type");
		sqlstr = (char *)_bstr_t(var);
	}
	catch (_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	int type = atoi(sqlstr);

	//We can add more transduce type and the corresponding transducer spacing value bellow
	//For TP10, we have 16 types
	switch (type){
	case 0:
		transType = "Standard-M";
		break;
	case 1:
		transType = "Insertion Type";
		break;
	case 2:
		transType = "Standard-S";
		break;
	case 3:
		transType = "User Type";
		break;
	case 4:
		transType = "Standard-B";
		break;
	case 5:
		transType = "Insertion B(45)";
		break;
	case 6:
		transType = "Standard-L";
		break;
	case 7:
		transType = "JH-Polysonics";
		break;
	case 8:
		transType = "Standard-HS";
		break;
	case 9:
		transType = "Standard-HM";
		break;
	case 10:
		transType = "Standard-M1";
		break;
	case 11:
		transType = "Standard-S1";
		break;
	case 12:
		transType = "Standard-L1";
		break;
	case 13:
		transType = "PI-Type";
		break;
	case 14:
		transType = "FS410(FUJI)";
		break;
	case 15:
		transType = "FS510(FUJI)";
		break;
	case 16:
		transType = "Clamp-on TM-1";
		break;
	case 17:
		transType = "Insertion TC-1";
		break;
	case 18:
		transType = "Clamp-On TS-1";
		break;
	case 19:
		transType = "Clamp-On TS-2";
		break;
	case 20:
		transType = "Clamp-On TL-1";
		break;
	case 21:
		transType = "Insertion TLC-2";
		break;
	case 22:
		transType = "Clamp-On M2";
		break;
	case 23:
		transType = "Clamp-On L2";
		break;
	case 24:
		transType = "TWC-HF0";
		break;
	case 25:
		transType = "TWC-HF1";
		break;
	case 26:
		transType = "TWC-HF2";
		break;
	case 27:
		transType = "TWC-HF3";
		break;
	case 28:
		transType = "TWC-HF4";
		break;
	case 29:
		transType = "TWC-HF5";
		break;
	case 30:
		transType = "TWC-HF6";
		break;
	case 31:
		transType = "TWC-RS2";
		break;
	case 32:
		transType = "TWC-RM";
		break;
	case 33:
		transType = "TWC-LF";
		break;
	case 34:
		transType = "TWC-HF0HT";
		break;
	default:
		transType = "Unkown";
		break;
	}
	return;
}

void CReminderDlg::calculateSpacing(){
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString str2;

	char menu5[6];
	int k;
	if (biaoleixing == 0)
	{
		char temp[6] = { '\x4d', '\x45', '\x4e', '\x55', '\x32', '\x35' };
		for (k = 0; k<6; k++)
		{
			menu5[k] = temp[k];
		}
	}
	else
	{
		char temp[6] = { '\x4d', '\x45', '\x4e', '\x55', '\x32', '\x35' };//Modified from 26 to 25
		for (k = 0; k<6; k++)
		{
			menu5[k] = temp[k];
		}
	}
	for (k = 0; k<6; k++)
	{
		str2 += menu5[k];
	}
	str2 += "\x26\x4c\x43\x44\x0d";

	str = str1 + str2;



	char buf[100] = { 0 };
	int pi = 0;
	int xnm = 0;
	do
	{
		app->g_com.Write(str);
		app->g_com.Read(buf, 100);
		if (biaoleixing == 0)
		{
			if (strstr(buf, "M25") != NULL || strstr(buf, "Spacing") != NULL)
			{
				pi = 1;
			}
		}
		else
		{
			if (strstr(buf, "M26") != NULL || strstr(buf, "Spacing") != NULL)
			{
				pi = 1;
			}
		}
		xnm++;
		if (xnm == 5)
		{
			break;
		}
	} while (!pi);
	str = "";
	str2 = "";
	Sleep(100);
	if (xnm == 5)
	{
		tranSpace = "Error";
	}
	else
	{
		char *p = buf;

		while (*p != '\0')
		{
			p++;
			if (biaoleixing == 0)
			{
				if (*p == 'M'&& *(p + 1) == '2' && *(p + 2) == '5' || *p == 'i' && *(p + 1) == 'n' && *(p + 2) == 'g')
				{
					p += 3;
					break;
				}
			}
			else
			{
				if (*p == 'M'&& *(p + 1) == '2' && *(p + 2) == '6' || *p == 'i' && *(p + 1) == 'n' && *(p + 2) == 'g')
				{
					p += 3;
					break;
				}
			}
		}
		char res[10] = { 0 };
		int n = 0;
		while (*p != '\0')
		{
			if (n < 10)
			{
				if (*p <= '9' && *p >= '0' || *p == '.' || *p == '-' || *p == 'E')
				{
					res[n++] = *p;
				}
				p++;
			}
		}
		if (n < 10)
			res[n] = '\0';
		//else 
		//res[9] = '\0';
		tranSpace.Format("%s", res);

		if (gyz == 0)
		{
			tranSpace += " mm";
		}
		else
		{
			tranSpace += " in";
		}
	}
}
void CReminderDlg::getM24(CString meter_no){

	CString sql;
	sql.Format("select transducer_mounting from Independent_settings where netword_IDN = %s", meter_no);
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("transducer_mounting");
		sqlstr = (char *)_bstr_t(var);
	}
	catch (_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	int type = atoi(sqlstr);

	//We have 4 types
	switch (type){
	case 0:
		mountType = "V-method";
		break;
	case 1:
		mountType = "Z-method";
		break;
	case 2:
		mountType = "N-method";
		break;
	case 3:
		mountType = "W-method";
		break;
	default:
		mountType = "Unknown";
		break;
	}
	return;
}