 // InstallDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Calibration.h"
#include "CalibrationDlg.h"
#include "InstallDlg.h"
#include "math.h" 
#include "Log.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInstallDlg dialog


CInstallDlg::CInstallDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CInstallDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CInstallDlg)
	//}}AFX_DATA_INIT
}


void CInstallDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInstallDlg)
	DDX_Control(pDX, IDC_LIST, m_list);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInstallDlg, CDialog)
	//{{AFX_MSG_MAP(CInstallDlg)
	ON_BN_CLICKED(IDC_CHECKOUT, OnCheckout)
	ON_BN_CLICKED(IDC_UPDATE, OnUpdate)
	ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInstallDlg message handlers
int __stdcall SetChildFont(struct HWND__ *,long);
//extern CFont *g_Font;

LRESULT   __stdcall   CBTHookProc(   long   nCode,WPARAM   wParam,LPARAM   lParam) ;
extern HHOOK   hHook; 

BOOL CInstallDlg::OnInitDialog() 
{	

	CDialog::OnInitDialog();
	// TODO: Add extra initialization here
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();

	LOGFONT lf;                        // Used to create the CFont.
	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.
	lf.lfHeight = 15;                  // Request a 20-pixel-high font
	strcpy(lf.lfFaceName, "Times New Roman");   
	if (g_font.m_hObject)
		g_font.DeleteObject();
	g_font.CreateFontIndirect(&lf);    // Create the font.

	if (app->language == 0)
	{
		this->SetWindowText("安装");
		m_list.InsertColumn(0,"表号",LVCFMT_LEFT,40); 
		m_list.InsertColumn(1,"序列号",LVCFMT_LEFT,70);
		m_list.InsertColumn(2,"距离",LVCFMT_LEFT,90);
		m_list.InsertColumn(3,"S",LVCFMT_LEFT,120);
		m_list.InsertColumn(4,"Q",LVCFMT_LEFT,50);
		m_list.InsertColumn(5,"R",LVCFMT_LEFT,100);
		m_list.InsertColumn(6,"state",LVCFMT_LEFT,67);
		GetDlgItem(IDC_UPDATE)->SetWindowText("更新");
		GetDlgItem(IDC_STATIC_INSTALL)->SetWindowText("安装");
/*		g_Font = new CFont;       
		g_Font->CreatePointFont(90, "宋体");*/
		::EnumChildWindows(m_hWnd, ::SetChildFont, (LPARAM)&g_font);
	}
	else
	{
		this->SetWindowText("Install");
		m_list.InsertColumn(0,"Netword IDN",LVCFMT_LEFT,40); 
		m_list.InsertColumn(1,"S/N",LVCFMT_LEFT,70);
		m_list.InsertColumn(2,"Transducer Spacing",LVCFMT_LEFT,90);
		m_list.InsertColumn(3,"S",LVCFMT_LEFT,120);
		m_list.InsertColumn(4,"Q",LVCFMT_LEFT,50);
		m_list.InsertColumn(5,"R",LVCFMT_LEFT,100);
		m_list.InsertColumn(6,"state",LVCFMT_LEFT,67);
		GetDlgItem(IDC_UPDATE)->SetFont(&g_font);
		GetDlgItem(IDC_UPDATE)->SetWindowText("Update");
		GetDlgItem(IDC_STATIC_INSTALL)->SetFont(&g_font);
		GetDlgItem(IDC_STATIC_INSTALL)->SetWindowText("Install");
		::EnumChildWindows(m_hWnd, ::SetChildFont, (LPARAM)&g_font);
	}

	//连接数据库
	//m_pAppConn.CreateInstance(__uuidof(Connection));
	//m_pAppConn->Open("File Name=MyData.udl", "", "", adConnectUnspecified);

	try
	{
		HRESULT hr = m_pAppConn.CreateInstance(__uuidof(Connection));
		if (FAILED(hr))
			AfxMessageBox("Can't create an intance of ADO.Connection");

		if (FAILED(m_pAppConn->Open(_bstr_t("File Name=MyData.udl"), _bstr_t(""), _bstr_t(""), adModeUnknown)))
			::AfxMessageBox(TEXT("Can't open datasource"));
		//m_pAppConn->Close();
	}
	catch (_com_error &e)
	{
		::AfxMessageBox(TEXT("I am in catch block 3"));
		_bstr_t bstrSource(e.Source());
		_bstr_t bstrDescription(e.Description());
		TRACE("Exception thrown for classes generated by #import");
		TRACE("\tCode = %08lx\n", e.Error());
		TRACE("\tCode meaning = %s\n", e.ErrorMessage());
		TRACE("\tSource = %s\n", (LPCTSTR)bstrSource);
		TRACE("\tDescription = %s\n", (LPCTSTR)bstrDescription);
	}
	catch (...)
	{
		TRACE("*** Unhandled Exception ***");
	}

	CString sql;
	sql.Format("USE settings");
	m_pAppConn->Execute((_bstr_t)sql,NULL,adCmdText);

	sql.Format("select measurement_units from Common_settings");
	m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
	_variant_t var = m_recordset->GetCollect("measurement_units");
	CString cstr = (char *)_bstr_t(var);
	sscanf(cstr, "%d", &gyz);
	sql.Format("SELECT netword_IDN,s_n,table_type FROM Independent_settings");
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		line = 0; 
		if (!m_recordset->adoEOF)
		{
			m_recordset->MoveFirst();
		}
		else
		{
			if (app->language == 0)
			{
				AfxMessageBox("没有发现表!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("Found no meter!");
			}
		}
		while (!m_recordset->adoEOF)
		{
			_variant_t var = m_recordset->GetCollect("netword_IDN");
			CString cstr = (char *)_bstr_t(var);
			m_list.InsertItem(line, (LPCTSTR)cstr);
			//W前缀
			int len = cstr.GetLength();
			str1 = "\x57";

			int j;
			for (j=0; j<len; j++)
			{
				switch(cstr.GetAt(j))
				{
				case '0':
					str1 += "\x30";
					break;
				case '1':
					str1 += "\x31";
					break;
				case '2':
					str1 += "\x32";
					break;
				case '3':
					str1 += "\x33";
					break;
				case '4':
					str1 += "\x34";
					break;
				case '5':
					str1 += "\x35";
					break;
				case '6':
					str1 += "\x36";
					break;
				case '7':
					str1 += "\x37";
					break;
				case '8':
					str1 += "\x38";
					break;
				case '9':
					str1 += "\x39";
					break;
				}
			}
			var = m_recordset->GetCollect("s_n");
			cstr = (char *)_bstr_t(var);
			m_list.SetItemText(line, 1, (LPCTSTR)cstr);
			var = m_recordset->GetCollect("table_type");
			cstr = (char *)_bstr_t(var);
			sscanf(cstr, "%d", &biaoleixing);

			GetM25();		
			GetS_Q();
			GetR();
			m_recordset->MoveNext();
			line++;
		}
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}	
	GetDlgItem(IDC_SHOW)->ShowWindow(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//获取S、Q值
void CInstallDlg::GetS_Q()
{
	//int i,j;
	//命令
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString str2 = ""; 
	str2 += "\x44\x4c\x0d";
	
	//发送消息
	str = str1 + str2;
	int fl = 1;
	char buf[60] = {0};
	int xnm = 0;
	do
	{
		app->g_com.Write(str);
		app->g_com.Read(buf, 60);
		Sleep(100);
		if (strstr(buf, "UP")!=NULL && strstr(buf, "DN")!=NULL)
		{
			fl = 0;
		}
		xnm++;
		if (xnm == 5)
		{
			break;
		}
	}
	while(fl);
	str = "";
	
	//接收消息
	if (xnm == 5)
	{
		m_list.SetItemText(line, 3, "ERROR");
		UpdateData(FALSE);
		m_list.SetItemText(line, 4, "ERROR");
		UpdateData(FALSE);
	}
	else
	{
		CString value_s;
		CString value_q;
		CString up;
		CString dn;
		char *p = strstr(buf, "UP");	
		if ((p = strstr(buf, "UP")) != NULL)
		{
			up.Format("%c%c%c%c", *(p+3), *(p+4), *(p+5), *(p+6));
		}
		if ((p = strstr(buf, "DN")) != NULL)
		{
			dn.Format("%c%c%c%c", *(p+3), *(p+4), *(p+5), *(p+6));
		}
		if ((p = strstr(buf, "Q=")) != NULL)
		{
			value_q.Format("%c%c", *(p+2), *(p+3));
		}			
		p = NULL;
		value_s.Format("UP:%s,DN:%s", up, dn);
		m_list.SetItemText(line, 3, value_s);
		UpdateData(FALSE);
		m_list.SetItemText(line, 4, value_q);
		UpdateData(FALSE);
	}
}

//获取R值
void CInstallDlg::GetR()
{
	//命令
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString str2 = "";                                
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x39', '\x31'};
	for (i=0; i<6; i++)
	{
		str2 += menu[i];
	}
	str2 += "\x26\x4c\x43\x44\x0d";
	
	//发送消息
	str = str1 + str2;
	
	
	//接收消息
	char buf[60] = {0};
	int bj = 0;
	int xnm = 0;	
	do
	{
		app->g_com.Write(str);
		app->g_com.Read(buf, 60);
		Sleep(100);
		if(strstr(buf, "时间比") != NULL || strstr(buf, "[91") != NULL)
		{
			bj = 1;
		}
		xnm++;
		if (xnm == 5)
		{
			break;
		}
	}while(!bj);
	str = "";
	Sleep(100);
	if (xnm == 5)
	{
		m_list.SetItemText(line, 5, "ERROR");
		UpdateData(FALSE);
	}
	else
	{
		char temp[20] = {0};
		char *p5 = NULL;
		if((p5 = strstr(buf, "时间比")) != NULL)
		{
			p5 += 9;
			strncpy(temp, p5, 16);
		}
		else if ((p5 = strstr(buf, "[91")) != NULL)
		{
			p5 += 6;
			strncpy(temp, p5, 16);
		}
		CString strtemp;
		strtemp.Format("%s", temp);
		strtemp.TrimLeft();
		
		p5 = NULL;
		m_list.SetItemText(line, 5, strtemp);
		UpdateData(FALSE);
	}
	
}

//校验
void CInstallDlg::OnCheckout() 
{
 	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	if (app->language == 0)
	{
		GetDlgItem(IDC_SHOW)->SetWindowText("校验中。。。");
	}
	else
	{
		GetDlgItem(IDC_SHOW)->SetWindowText("Checking...");
	}
	KillTimer(1);
	int i,j;
	int count = m_list.GetItemCount();
	CString element;
	for (i=0; i<count; i++)
	{
		element = m_list.GetItemText(i, 0);
		int len = element.GetLength();
		int flag = 1; // 1 表示正确，0 表示错误, the state of the meter
		strBeg = "\x57";

		for (j=0; j<len; j++)
		{
			switch(element.GetAt(j))
			{
			case '0':
				strBeg += "\x30";
				break;
			case '1':
				strBeg += "\x31";
				break;
			case '2':
				strBeg += "\x32";
				break;
			case '3':
				strBeg += "\x33";
				break;
			case '4':
				strBeg += "\x34";
				break;
			case '5':
				strBeg += "\x35";
				break;
			case '6':
				strBeg += "\x36";
				break;
			case '7':
				strBeg += "\x37";
				break;
			case '8':
				strBeg += "\x38";
				break;
			case '9':
				strBeg += "\x39";
				break;
			
			}
		}

		CString tempo;
		tempo.Format("%d", adCmdText);
		Log::Logger("CheckM25 b4 calling m25 the adCmdText is " + tempo);


		if (!CheckM11())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号管道外直径设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " pipe outer diameter set failure!");
			}	
			flag = 0;
		}
		else if (!CheckM12())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号管道管壁厚度设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " pipe wall thickness set failure!");
			}	
			flag = 0;
		}	
		else if (!CheckM13())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号管道内直径设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " pipe inner diameter set failure!");
			}
			flag = 0;
		}
		else if (!CheckM14())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号管道材质类型设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " pipe material set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM16())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号衬里材质类型设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " liner material set failure!");
			}
			flag = 0;
		}
		else if (!CheckM18())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号衬里厚度设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " liner thickness set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM20())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号流体类型设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " fluid type set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM31())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号瞬时流量单位设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " flow rate unit set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM32())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号累计流量单位设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " totalizer units set failure!");
			}
			flag = 0;
		}
		else if (!CheckM33())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号累计倍乘因子设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " totalizer multiplier set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM34())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号净累积器开关设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " NET totalizer set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM35())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号正累积器开关设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " POS totalizer  set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM36())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号负累积器开关设置失效!");	
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " NEG totalizer set failure!");
			}
		
			flag = 0;
		}
		else if (!CheckM39())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号Language_LINGUA设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " language LINGUA set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM40())
		{ 
			if (app->language == 0)
			{
				AfxMessageBox(element + "号阻尼系数设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " damping factor set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM79())
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号继电器输出设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " RELAY output setup set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM23(element))
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号传感器类型设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " transducer type set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM24(element))
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号传感器工作频率设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " transducer frequency set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckM25(element))
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号传感器安装方法设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " transducer mounting set failure!");
			}	
			flag = 0;
		}
		else if (!CheckM45(element))
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号仪表系数设置失效!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + " scale factor set failure!");
			}
			
			flag = 0;
		}
		else if (!CheckS(i))
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号S值不符合要求!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + ", the value of S not meet the requirements!");
			}
			
			flag = 0;
		}
		else if (!CheckQ(i))
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号Q值不符合要求!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + ", the value of Q not meet the requirements!");
			}
			
			flag = 0;
		}
		else if (!CheckR(i))
		{
			if (app->language == 0)
			{
				AfxMessageBox(element + "号R值不符合要求!");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("IDN " + element + ", the value of R not meet the requirements!");
			}
			
			flag = 0;
		}
		CString sql;
		sql.Format("UPDATE Independent_settings SET state=%d WHERE netword_IDN=%s", flag, element);
		try
		{
			m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
			app->Meters[i].Installed = flag;
		}
		catch(_com_error e)
		{
			AfxMessageBox(e.ErrorMessage());
		}
		if ( flag == 0)
		{
			m_list.SetItemText(i, 6, "NO");
		}
		else
		{
			m_list.SetItemText(i, 6, "YES");
		}
	}
}

//pipe_outer_diameter校验
BOOL CInstallDlg::CheckM11()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x31', '\x31'};
	for (i=0; i<6; i++)
	{
		strEnd += CString(menu[i]); 
	}
	strEnd += "\x26\x4c\x43\x44";

	str = strBeg + strEnd + "\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	char *p = buf;
	app->g_com.Read(buf, 60);
	while (*p != '\0')
	{
		p++;
		if (*p == 'M' && *(p+1) == '1' && *(p+2) == '1' || *p == 't' && *(p+1) == 'e' && *(p+2) == 'r')
		{
			p += 3;
			break;
		}
	}
	Sleep(100);	
	char res[10] = {0};
	int n = 0;
	while (*p != '\0')
	{
		if (*p <= '9' && *p >= '0' || *p == '.' || *p == '-')
		{
			res[n++] = *p ;
		}
		p++;
	}

	p = NULL;
	//res[n] = '\0';
	CString readstr;
	readstr.Format("%s", res);
	float r_m;
	sscanf(readstr, "%f", &r_m);
	float s_m;

	CString sql;
	sql.Format("select pipe_outer_diameter from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("pipe_outer_diameter");
		sqlstr = (char *)_bstr_t(var);
		
		sscanf(sqlstr, "%f", &s_m);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (fabs(s_m-r_m) >= 0.001)
	{
		return FALSE;
	}
	return TRUE;
}

//pipe_wall_thickness校验
BOOL CInstallDlg::CheckM12()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x31', '\x32'};
	for (i=0; i<6; i++)
	{
		strEnd += menu[i];
	}

	str = strBeg + strEnd + "\x0d";

	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	while (*p != '\0')
	{
		p++;
		if (*p == 'M' && *(p+1) == '1' && *(p+2) == '2' || *p == 'e' && *(p+1) == 's' && *(p+2) == 's')
		{
			p += 3;
			break;
		}
	}
	char res[10] = {0};
	int n = 0;
	while (*p != '\0')
	{
		if (*p <= '9' && *p >= '0' || *p == '.' || *p == '-')
		{
			res[n++] = *p ;
		}
		p++;
	}
	res[n] = '\0';
	CString readstr;
	readstr.Format("%s", res);
	float r_m;
	sscanf(readstr, "%f", &r_m);
	float s_m;
	
	CString sql;
	sql.Format("select pipe_wall_thickness from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("pipe_wall_thickness");
		sqlstr = (char *)_bstr_t(var);
		sscanf(sqlstr, "%f", &s_m);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (fabs(s_m-r_m) >= 0.001)
	{
		return FALSE;
	}
	return TRUE;
}

//pipe_inner_diameter校验
BOOL CInstallDlg::CheckM13()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x31', '\x33'};
	for (i=0; i<6; i++)
	{
		strEnd += menu[i];
	}

	str = strBeg + strEnd + "\x0d";

	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	while (*p != '\0')
	{
		p++;
		if (*p == 'M' && *(p+1) == '1' && *(p+2) == '3' || *p == 't' && *(p+1) == 'e' && *(p+2) == 'r')
		{
			p += 3;
			break;
		}
	}
	char res[10] = {0};
	int n = 0;
	while (*p != '\0')
	{
		if (*p <= '9' && *p >= '0' || *p == '.' || *p == '-')
		{
			res[n++] = *p ;
		}
		p++;
	}
	res[n] = '\0';
	CString readstr;
	readstr.Format("%s", res);
	float r_m;
	sscanf(readstr, "%f", &r_m);
	float s_m;
	
	CString sql;
	sql.Format("select pipe_inner_diameter from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("pipe_inner_diameter");
		sqlstr = (char *)_bstr_t(var);
		sscanf(sqlstr, "%f", &s_m);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}

	if (fabs(s_m-r_m) >= 0.001)
	{
		return FALSE;
	}
	return TRUE;
}

//pipe_material校验
BOOL CInstallDlg::CheckM14()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d','\x45', '\x4e', '\x55', '\x31', '\x34'};
	for (i=0; i<6; i++)
	{
		strEnd += CString(menu[i]);
	}

	str = strBeg + strEnd + "\x0d";

	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	char res[3] = {0};
	while (*p != '\0')
	{
		p++;
		if (*p == '.')
		{
			res[0] = *(p-2);
			res[1] = *(p-1);
			break;
		}
	}
	res[2] = '\0';
	CString readstr;
	readstr.Format("%s", res);
	readstr.TrimLeft();
	
	CString sql;
	sql.Format("select pipe_material from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("pipe_material");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;
}

//liner_material校验
BOOL CInstallDlg::CheckM16()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x31', '\x36'};
	for (i=0; i<6; i++)
	{
		strEnd += menu[i];
	}
	str = strBeg + strEnd + "\x0d";

	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	char res[3] = {0};
	while (*p != '\0')
	{
		p++;
		if (*p == '.')
		{
			res[0] = *(p-2);
			res[1] = *(p-1);
			break;
		}
	}
	res[2] = '\0';
	CString readstr;
	readstr.Format("%s", res);
	readstr.TrimLeft();
	
	CString sql;
	sql.Format("select liner_material from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("liner_material");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;
}

//liner_thickness校验
BOOL CInstallDlg::CheckM18()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x31', '\x38'};
	for (i=0; i<6; i++)
	{
		strEnd += menu[i];
	}
	str = strBeg + strEnd + "\x0d";

	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	while (*p != '\0')
	{
		p++;
		if (*p == 'M' && *(p+1) == '1' && *(p+2) == '8' || *p == '[' && *(p+1) == '1' && *(p+2) == '8')
		{
			p += 3;
			break;
		}
	}
	char res[10] = {0};
	int n = 0;
	while (*p != '\0')
	{
		if (*p <= '9' && *p >= '0' || *p == '.' || *p == '-')
		{
			res[n++] = *p ;
		}
		p++;
	}
	res[n] = '\0';
	CString readstr;
	readstr.Format("%s", res);
	float r_m;
	sscanf(readstr, "%f", &r_m);
	float s_m;
	
	CString sql;
	sql.Format("select liner_thickness from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("liner_thickness");
		sqlstr = (char *)_bstr_t(var);
		sscanf(sqlstr, "%f", &s_m);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr.IsEmpty() && sqlstr == "0")
	{
		return TRUE;
	}
	if (fabs(s_m-r_m) >= 0.001)
	{
		return FALSE;
	}
	return TRUE;
}

//fluid_type校验
BOOL CInstallDlg::CheckM20()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x32', '\x30'};
	for (i=0; i<6; i++)
	{
		strEnd += menu[i];
	}
	str = strBeg + strEnd + "\x0d";

	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\0x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	char res[3] = {0};
	while (*p != '\0')
	{
		p++;
		if (*p == '.')
		{
			res[0] = *(p-2);
			res[1] = *(p-1);
			break;
		}
	}
	res[2] = '\0';
	CString readstr;
	readstr.Format("%s", res);
	readstr.TrimLeft();
	
	CString sql;
	sql.Format("select fluid_type from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("fluid_type");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	/*if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;*/
	if (readstr.IsEmpty() && sqlstr == "0")
	{
		return TRUE;
	}
	return FALSE;
}

//flow_rate_unit校验
BOOL CInstallDlg::CheckM31()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x33', '\x31'};
	for (i=0; i<6; i++)
	{
		strEnd += menu[i];
	}

	str = strBeg + strEnd + "\x0d";

	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	char res[10] = {0};
	while (*p != '\0')
	{
		p++;
		if (*p == 'M' && *(p+1) == '3' && *(p+2) == '1' || *p == '[' && *(p+1) == '3' && *(p+2) == '1')
		{
			p += 3;
			break;
		}
	}
	int n = 0;
	while (*p != '\0')
	{
		if (*p >= 'a' && *p <= 'z' || *p >= 'A' && *p <= 'Z' || *p >= '0' && *p <= '9' || *p == '/')
		{
			res[n++] = *p;
		}
		p++;
	}
	res[n] = '\0';
	CString readstr;
	readstr.Format("%s", res);
	
	CString sql;
	sql.Format("select flow_rate_unit from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("flow_rate_unit");
		CString cstr = (char *)_bstr_t(var);
		char u_v(cstr.GetAt(0));
		sscanf_s(&u_v, "%d", &app->unit_volume);
		switch (u_v)
		{
		default:
		case '0':
			sqlstr = "m3";
			break;
		case '1':
			sqlstr = "l";
			break;
		case '2':
			sqlstr = "g";
			break;
		case '3':
			sqlstr = "ig";
			break;
		case '4':
			sqlstr = "Mg";
			break;
		case '5':
			sqlstr = "cf";
			break;
		case '6':
			sqlstr = "ob";
			break;
		case '7':
			sqlstr = "ib";
			break;
		}
		sqlstr += "/";

		char u_t(cstr.GetAt(2));
		sscanf_s(&u_t, "%d", &app->unit_time);
		switch(u_t)
		{
		default:
		case '0':
			sqlstr += "s";
			break;
		case '1':
			sqlstr += "m";
			break;
		case '2':
			sqlstr += "h";
			break;
		case '3':
			sqlstr += "d";
			break;
		}
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	//if (readstr != sqlstr)
	//{
	//	return FALSE;
	//}
	//return TRUE;

	if (readstr.IsEmpty() && sqlstr == "g/m")
	{
		return TRUE;
	}
	return FALSE;
}
	
//totalizer_units校验
BOOL CInstallDlg::CheckM32()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x33', '\x32'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}
	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	Sleep(100);
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	CString readstr;
	while (*p != '\0')
	{
		p++;
		if (*p == 'M' && *(p+1) == '3' && *(p+2) == '2' || *p == '[' && *(p+1) == '3' && *(p+2) == '2')
		{
			p += 3;
			break;
		}
	}
	int n = 0;
	while (*p != '\0')
	{
		if (*p == 'm' && *(p+1) == '3')
		{
			readstr = "0";
		}
		else if (*p == '(' && *(p+1) == 'L' || *p == '(' && *(p+1) == 'l')
		{
			readstr = "1";
		}
		else if (*p == 'G' && *(p+1) == 'A' && *(p+2) == 'L' || *p == '(' && *(p+1) == 'G' && *(p+2) == 'a' && *(p+3) == 'l')
		{
			readstr = "2";
		}
		else if (*p == 'I' && *(p+1) == 'G' && *(p+2) == 'L')
		{
			readstr = "3";
		}
		else if (*p == 'M' && *(p+1) == 'G' && *(p+2) == 'L' || *p == 'M' && *(p+1) == 'i' && *(p+2) == 'l')
		{
			readstr = "4";
		}
		else if (*p == 'C' && *(p+1) == 'F'|| *p == 'c' && *(p+1) == 'f')
		{
			readstr = "5";
		}
		else if (*p == 'O' && *(p+1) == 'B')
		{
			readstr = "6";
		}
		else if (*p == 'I' && *(p+1) == 'B')
		{
			readstr = "7";
		}
		p++;
	}

	CString sql;
	sql.Format("select totalizer_units from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("totalizer_units");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;
}

//totalizer_multiplier校验
BOOL CInstallDlg::CheckM33()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x33', '\x33'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}
	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	char res[3] = {0};
	while (*p != '\0')
	{
		p++;
		if (*p == '.')
		{
			res[0] = *(p-2);
			res[1] = *(p-1);
			break;
		}
	}
	res[2] = '\0';
	CString readstr;
	readstr.Format("%s", res);
	readstr.TrimLeft();
	
	CString sql;
	sql.Format("select totalizer_multiplier from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("totalizer_multiplier");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	//if (strstr(readstr, "3")) Modified by YC, should check if the read string is same as the set string
	if (strstr(readstr, sqlstr))
		return TRUE;
	return FALSE;
}

//net_toalizer校验
BOOL CInstallDlg::CheckM34()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	CString menu[6] = {"\x4d", "\x45", "\x4e", "\x55", "\x33", "\x34"};
	for (i = 0; i<6; i++)
	{
		strEnd +=menu[i];
	}
	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	str += strBeg +"\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	CString readstr;
	while (*p != '\0')
	{
		if (*p == 'O' && *(p+1) == 'N')
		{
			readstr = "-1"; //modified by YC
			//readstr = "1";
		}
		if (*p == 'O' && *(p+1) == 'F')
		{
			readstr = "0";
		}
		p++;
	}
	
	CString sql;
	sql.Format("select net_toalizer from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("net_toalizer");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	//if (readstr.IsEmpty() && sqlstr == "0")Modified by YC, the read string should be same as the set string
	if (strstr(readstr, sqlstr))
		return TRUE;
	return FALSE;
}

//pos_totalizer校验
BOOL CInstallDlg::CheckM35()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x33', '\x35'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}

	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	CString readstr;
	while (*p != '\0')
	{
		if (*p == 'O' && *(p+1) == 'N')
		{
			readstr = "-1";
		}
		if (*p == 'O' && *(p+1) == 'F')
		{
			readstr = "0";
		}
		p++;
	}
	
	CString sql;
	sql.Format("select pos_totalizer from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("pos_totalizer");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;
}
	
//neg_totalizer校验
BOOL CInstallDlg::CheckM36()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x33', '\x36'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}

	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	CString readstr;
	while (*p != '\0')
	{
		if (*p == 'O' && *(p+1) == 'N')
		{
			readstr = "-1";
		}
		if (*p == 'O' && *(p+1) == 'F')
		{
			readstr = "0";
		}
		p++;
	}
	
	CString sql;
	sql.Format("select neg_totalizer from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("neg_totalizer");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;
}

//Language_LINGUA校验
BOOL CInstallDlg::CheckM39()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x33', '\x39'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}
	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	CString readstr;
	while (*p != '\0')
	{
		if (*p == 'Z' && *(p+1) == 'h')
		{
			readstr = "1";
		}
		else if (*p == 'E' && *(p+1) == 'n')
		{
			readstr = "0";
		}
		else if (*p == 'I' && *(p+1) == 't')
		{
			readstr = "2";
		}
		p++;
	}
	
	CString sql;
	sql.Format("select Language_LINGUA from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("Language_LINGUA");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;
}

//damping_factor校验
BOOL CInstallDlg::CheckM40()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = { '\x4d', '\x45', '\x4e', '\x55', '\x34', '\x30' };
	for (i = 0; i<6; i++)
	{
		strEnd += CString(menu[i]);
	}
	strEnd += "\x26\x4c\x43\x44";

	str = strBeg + strEnd + "\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = { 0 };
	char *p = buf;
	app->g_com.Read(buf, 60);
	while (*p != '\0')
	{
		p++;
		if (*p == 'p' && *(p + 1) == 'i' && *(p + 2) == 'n')//Damping
		{
			p += 17;
			break;
		}
	}
	Sleep(100);
	char res[10] = { 0 };
	int n = 0;
	while (*p != '\0')
	{
		if (*p <= '9' && *p >= '0' || *p == '.' || *p == '-')
		{
			res[n++] = *p;
		}
		p++;
	}

	p = NULL;
	CString readstr;
	readstr.Format("%s", res);
	

	CString sql;
	sql.Format("select damping_factor from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("damping_factor");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr== sqlstr)
	{
		return TRUE;
	}
	return FALSE;
	//return TRUE;
}
	
//relay_output_setup校验
BOOL CInstallDlg::CheckM79()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x37', '\x39'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}

	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	CString readstr;
	char res[3] = {0};
	while (*p != '\0')
	{
		if (*p == '.')
		{
			res[0] = *(p-2);
			res[1] = *(p-1);
		}
		p++;
	}
	res[2] = '\0';
	readstr.Format("%s", res);
	readstr.TrimLeft();

	CString sql;
	sql.Format("select relay_output_setup from Common_settings");
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("relay_output_setup");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;
}

//transducer_type校验
BOOL CInstallDlg::CheckM23(CString meter_no)
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x32', '\x33'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}
	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	CString readstr;
	char res[3] = {0};
	while (*p != '\0')
	{
		if (*p == '.')
		{
			res[0] = *(p-2);
			res[1] = *(p-1);
		}
		p++;
	}
	res[2] = '\0';
	readstr.Format("%s", res);
	readstr.TrimLeft();
	
	CString sql;
	sql.Format("select transducer_type from Independent_settings where netword_IDN = %s", meter_no);
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("transducer_type");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;
}
	
//
BOOL CInstallDlg::CheckM24(CString meter_no)
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x32', '\x34'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}
	str = strBeg + strEnd + '\x0d';
	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	CString readstr;
	char res[3] = {0};
	while (*p != '\0')
	{
		if (*p == '.')
		{
			res[0] = *(p-2);
			res[1] = *(p-1);
		}
		p++;
	}
	res[2] = '\0';
	readstr.Format("%s", res);
	readstr.TrimLeft();
	
	CString sql;
	
	sql.Format("select table_type from Independent_settings where netword_IDN=%s", meter_no);
	int biaoleixing;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("table_type");
		CString str = (char *)_bstr_t(var);
		sscanf(str, "%d", &biaoleixing);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}

	CString sqlstr;
	if (biaoleixing == 1)
	{
		sql.Format("select transducer_frequency from Independent_settings where netword_IDN=%s and table_type=1", meter_no);	
		try
		{
			m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
			_variant_t var = m_recordset->GetCollect("transducer_frequency");
			sqlstr = (char *)_bstr_t(var);
		}
		catch(_com_error e)
		{
			AfxMessageBox(e.ErrorMessage());
		}
	}
	else
	{
		sql.Format("select transducer_mounting from Independent_settings where netword_IDN=%s and table_type=0", meter_no);
		try
		{
			m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
			_variant_t var = m_recordset->GetCollect("transducer_mounting");
			sqlstr = (char *)_bstr_t(var);
		}
		catch(_com_error e)
		{
			AfxMessageBox(e.ErrorMessage());
		}
	}
	
	if (readstr != sqlstr)
	{
		Log::Logger("CheckM24 the readstr is " + readstr);
		Log::Logger("CheckM24 the sqlstr is " + sqlstr);
		Log::Logger("CheckM24 return false");

		return FALSE;
	}
	return TRUE;
}

//
BOOL CInstallDlg::CheckM25(CString meter_no)
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	//switch to menu 25
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x32', '\x35'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}
	Log::Logger("CheckM25 b4 change strBeg is " + strBeg);

	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";
	Log::Logger("CheckM25 the str write to app->g_com.Write(str) is " + str);


	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	CString test = CString(buf);

	Log::Logger("CheckM25 the buf b4 sleep is " + test);
	Sleep(100);
	test = CString(buf);

	Log::Logger("CheckM25 the buf after sleep is " + test);

	char *p = buf;
	CString readstr;
	char res[3] = {0};
	while (*p != '\0')
	{
		if (*p == '.')
		{
			res[0] = *(p-2);
			Log::Logger("CheckM25 the res[0] is " + CString(res[0]));

			res[1] = *(p-1);
			Log::Logger("CheckM25 the res[1] is " + CString(res[1]));

		}
		p++;
	}
	res[2] = '\0';
	readstr.Format("%s", res);
	readstr.TrimLeft();
	Log::Logger("CheckM25 the res[2] is " + CString(res));
	Log::Logger("CheckM25 the readstr is " + readstr);

	CString sql;

	sql.Format("select table_type from Independent_settings where netword_IDN=%s", meter_no);
	int biaoleixing;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("table_type");
		CString str = (char *)_bstr_t(var);
		Log::Logger("CheckM25 the table_type is " + str);
		CString temp;
		temp.Format("%d", biaoleixing);
		Log::Logger("CheckM25 the biaoleixing is " + temp);

		sscanf(str, "%d", &biaoleixing);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}

	if (biaoleixing == 0)
	{
		return TRUE;
	}
	else
	{
		sql.Format("select transducer_mounting from Independent_settings where netword_IDN = %s", meter_no);

		CString temp;
		temp.Format("%d", adCmdText);
		Log::Logger("CheckM25 the adCmdText is " + temp);
		Log::Logger("CheckM25 the meter_no is " + meter_no);
		Log::Logger("CheckM25 the sql is " + sql);

		CString sqlstr;
		try
		{
			m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
			_variant_t var = m_recordset->GetCollect("transducer_mounting");
			sqlstr = (char *)_bstr_t(var);
		}
		catch(_com_error e)
		{
			AfxMessageBox(e.ErrorMessage());
		}
		if (readstr != sqlstr)
		{
			Log::Logger("CheckM25 the readstr is " + readstr);
			Log::Logger("CheckM25 the sqlstr is " + sqlstr);
			Log::Logger("CheckM25 return false");


			//return FALSE;
			return TRUE;
		}
		return TRUE;
	}
	
}
	
//scale_factor校验
BOOL CInstallDlg::CheckM45(CString meter_no)
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString strEnd;
	int i;
	char menu[6] = {'\x4d', '\x45', '\x4e', '\x55', '\x34', '\x35'};
	for (i = 0; i<6; i++)
	{
		strEnd += menu[i];
	}
	str = strBeg + strEnd + "\x0d";
	app->g_com.Write(str);
	str = "";
	str += strBeg + "\x4c\x43\x44\x0d";

	app->g_com.Write(str);
	str = "";
	char buf[60] = {0};
	app->g_com.Read(buf, 60);
	Sleep(100);
	char *p = buf;
	CString readstr;
	char res[10] = {0};
	p += 10;
	int n = 0;
	while (*p != '\0')
	{
		if(*p == '[' && *(p+1) == '4' && *(p+2) == '5')
		{
			p += 3;
			break;
		}
		else if(IsDBCSLeadByte(*p))
		{
			break;
		}
		p++;
	}
	while(*p != '\0')
	{
		if (*p <= '9' && *p >= '0' || *p == '.')
		{
			res[n++] = *p;
		}
		p++;
	}
	res[n] = '\0';
	readstr.Format("%s", res);
	
	CString sql;
	sql.Format("select scale_factor from Independent_settings where netword_IDN = %s", meter_no);
	CString sqlstr;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		_variant_t var = m_recordset->GetCollect("scale_factor");
		sqlstr = (char *)_bstr_t(var);
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}
	if (readstr != sqlstr)
	{
		return FALSE;
	}
	return TRUE;
}

BOOL CInstallDlg::CheckS(int i)
{
	CString s;
	s = m_list.GetItemText(i, 3);
	CString substr = s.Mid(3, 4);
	CString substr2 = s.Mid(11, 4);
	float up, dn;
	sscanf(substr, "%f", &up);
	sscanf(substr2, "%f", &dn);
	if (up > 60 && dn > 60 && fabs(up - dn) <= 0.3)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CInstallDlg::CheckQ(int i)
{
	CString s;
	s = m_list.GetItemText(i, 4);
	float q;
	sscanf(s, "%f", &q);
	if (q > 60)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CInstallDlg::CheckR(int i)
{
	CString s;
	s = m_list.GetItemText(i, 5);
	int nPos = s.ReverseFind('%');
	CString str_r = s.Left(nPos);
	float r;
	sscanf(str_r, "%f", &r);
	if (r <= 103 && r >= 97)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void CInstallDlg::OnUpdate()
{
	//连接数据库
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	GetDlgItem(IDC_UPDATE)->EnableWindow(FALSE);
	GetDlgItem(IDC_SHOW)->ShowWindow(TRUE);
	UpdateData(FALSE);
	//m_pAppConn.CreateInstance(__uuidof(Connection));
	//m_pAppConn->Open("File Name=MyData.udl", "", "", adConnectUnspecified);

	try
	{
		HRESULT hr = m_pAppConn.CreateInstance(__uuidof(Connection));
		if (FAILED(hr))
			AfxMessageBox("Can't create an intance of ADO.Connection");

		if (FAILED(m_pAppConn->Open(_bstr_t("File Name=MyData.udl"), _bstr_t(""), _bstr_t(""), adModeUnknown)))
			::AfxMessageBox(TEXT("Can't open datasource"));
		//m_pAppConn->Close();
	}
	catch (_com_error &e)
	{
		::AfxMessageBox(TEXT("Cannot open database, check MyData.udl"));
		_bstr_t bstrSource(e.Source());
		_bstr_t bstrDescription(e.Description());
		TRACE("Exception thrown for classes generated by #import");
		TRACE("\tCode = %08lx\n", e.Error());
		TRACE("\tCode meaning = %s\n", e.ErrorMessage());
		TRACE("\tSource = %s\n", (LPCTSTR)bstrSource);
		TRACE("\tDescription = %s\n", (LPCTSTR)bstrDescription);
	}
	catch (...)
	{
		TRACE("*** Unhandled Exception ***");
	}
	
	CString sql;;
	sql.Format("use settings");
	m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
	sql.Format("select measurement_units from Common_settings");
	m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
	_variant_t var = m_recordset->GetCollect("measurement_units");
	CString cstr = (char *)_bstr_t(var);
	sscanf(cstr, "%d", &gyz);

	sql.Format("select netword_IDN,s_n,table_type from Independent_settings");
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		line = 0; 
		if (!m_recordset->adoEOF)
		{
			m_recordset->MoveFirst();
		}
		else
		{
			if (app->language == 0)
			{
				AfxMessageBox("没有发现表");
			}
			else
			{
				hHook=SetWindowsHookEx(WH_CBT,(HOOKPROC)CBTHookProc,AfxGetInstanceHandle(),NULL); 
				AfxMessageBox("Found no meter");
			}
		}
		while (!m_recordset->adoEOF)
		{
			_variant_t var = m_recordset->GetCollect("netword_IDN");
			CString cstr = (char *)_bstr_t(var);
		//	m_list.InsertItem(line, (LPCTSTR)cstr);
			//W前缀
			int len = cstr.GetLength();//Find how many testing meters are connected 
			str1 = "\x57";

			int j;
			for (j=0; j<len; j++)
			{
				switch(cstr.GetAt(j))
				{
				case '0':
					str1 += "\x30";
					break;
				case '1':
					str1 += "\x31";
					break;
				case '2':
					str1 += "\x32";
					break;
				case '3':
					str1 += "\x33";
					break;
				case '4':
					str1 += "\x34";
					break;
				case '5':
					str1 += "\x35";
					break;
				case '6':
					str1 += "\x36";
					break;
				case '7':
					str1 += "\x37";
					break;
				case '8':
					str1 += "\x38";
					break;
				case '9':
					str1 += "\x39";
					break;
				}
			}
			var = m_recordset->GetCollect("s_n");
			cstr = (char *)_bstr_t(var);
			m_list.SetItemText(line, 1, (LPCTSTR)cstr);
			UpdateData(FALSE);
			var = m_recordset->GetCollect("table_type");
			cstr = (char *)_bstr_t(var);
			sscanf(cstr, "%d", &biaoleixing);
			
			GetM25();
			GetS_Q();
			GetR();
			m_recordset->MoveNext();
			line++;
		}
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}	
	UpdateData(FALSE);
	OnCheckout();
	GetDlgItem(IDC_UPDATE)->EnableWindow(TRUE);
	GetDlgItem(IDC_SHOW)->ShowWindow(FALSE);
}

HBRUSH CInstallDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
	
	// TODO: Change any attributes of the DC here
	if( pWnd->GetDlgCtrlID() == IDC_SHOW )
	{
		pDC->SetTextColor(RGB(255,0,0)); //字体颜色
    }
	// TODO: Return ai different brush if the default is not desired
	return hbr;
}

void CInstallDlg::GetM25()
{
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	CString str2;
	
	char menu5[6];
	int k;
	if (biaoleixing == 0)
	{
		char temp[6] =  {'\x4d', '\x45', '\x4e', '\x55', '\x32', '\x35'};
		for (k=0; k<6; k++)
		{
			menu5[k] = temp[k];
		}
	}
	else
	{
		char temp[6] = { '\x4d', '\x45', '\x4e', '\x55', '\x32', '\x36' };
		for (k=0; k<6; k++)
		{
			menu5[k] = temp[k];
		}
	}	
	for (k=0; k<6; k++)
	{
		str2 += menu5[k];		
	}
	str2 += "\x26\x4c\x43\x44\x0d";

	str = str1 + str2;
	
	
	
	char buf[100] = {0};
	int pi = 0;
	int xnm = 0;
	do 
	{
		app->g_com.Write(str);
		app->g_com.Read(buf, 100); 
		if (biaoleixing == 0)
		{
			if (strstr(buf, "M25")!=NULL || strstr(buf, "Spacing")!=NULL)
			{
				pi = 1;
			}
		}
		else
		{
			if (strstr(buf, "M26")!=NULL || strstr(buf, "Spacing")!=NULL)
			{
				pi = 1;
			}
		}
		xnm++;
		if (xnm == 5)
		{
			break;
		}
	} while (!pi);
	str = "";
	str2 = "";
	Sleep(100);
	if (xnm == 5)
	{
		m_list.SetItemText(line, 2, "ERROR");
	}
	else
	{
		char *p = buf;
		
		while (*p != '\0')
		{
			p++;
			if (biaoleixing == 0)
			{
				if ( *p == 'i' && *(p+1) == 'n' && *(p+2) == 'g')
				{
					p += 3;
					break;
				}
			}
			else
			{
				if ( *p == 'i' && *(p+1) == 'n' && *(p+2) == 'g')
				{
					p += 3;
					break;
				}
			}	
		}
		char res[10] = {0};
		int n = 0;
		while (*p != '\0')
		{
			if (n < 10)
			{
				if (*p <= '9' && *p >= '0' || *p == '.' || *p == '-' || *p == 'E')
				{
					res[n++] = *p;
				}
				p++;
			}
			else break;
		}
		if (n<10)
			res[n] = '\0';
		//else 
			//res[9] = '\0';
		CString cstr;
		cstr.Format("%s", res);
		
		if (gyz == 0)
		{
			cstr += " mm";
		}
		else
		{
			cstr += " in";
		}
		m_list.SetItemText(line, 2, (LPCTSTR)cstr);
	}
}

void CInstallDlg::OnClose()
{
	if (m_recordset)
		if (m_recordset->State == adStateOpen)
			m_recordset->Close();
	if (m_pAppConn)
		if (m_pAppConn->State == adStateOpen)
			m_pAppConn->Close();

	m_pAppConn.Release();

	CDialog::OnClose();
}

void CInstallDlg::OnDestroy()
{
	CDialog::OnDestroy();
	this->DestroyWindow();
	::PostQuitMessage(0);
}
