// CollectDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Calibration.h"
#include "CollectDlg.h"
#include "CalibrationDlg.h"
#include "SetZeroDlg.h"
#include"Meter_Operation.h"
#include<iostream>
#include<fstream>

using namespace std;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCollectDlg dialog


CCollectDlg::CCollectDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCollectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCollectDlg)
	// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CCollectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCollectDlg)
	DDX_Control(pDX, IDC_PRO, m_pro);
	DDX_Control(pDX, IDC_LIST_COLLECT, m_list);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCollectDlg, CDialog)
	//{{AFX_MSG_MAP(CCollectDlg)
	ON_WM_TIMER()
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCollectDlg message handlers
LRESULT   __stdcall   CBTHookProc(long   nCode, WPARAM   wParam, LPARAM   lParam);
extern HHOOK   hHook;

int __stdcall SetChildFont(struct HWND__ *, long);
//extern CFont *g_Font;

int endflag;             //定时器结束标志   0、运行  1、结束

BOOL CCollectDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// TODO: Add extra initialization here
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();

	LOGFONT lf;                        // Used to create the CFont.
	memset(&lf, 0, sizeof(LOGFONT));   // Clear out structure.
	lf.lfHeight = 15;                  // Request a 20-pixel-high font
	strcpy(lf.lfFaceName, "Times New Roman");
	if (g_font.m_hObject)
		g_font.DeleteObject();
	g_font.CreateFontIndirect(&lf);    // Create the font.

	if (!app->g_com.IsOpen())
	{
		//app->g_com.Open(app->commm, 9600, NOPARITY, 8, ONESTOPBIT);
		app->g_com.Open(app->commm, 9600, NOPARITY, 8, TWOSTOPBITS);
	}
	if (app->language == 0)
	{
		if (app->flux.Compare("小") == 0)
		{
			this->SetWindowText("采集数据:Qmin");
		}
		else if (app->flux.Compare("中") == 0)
		{
			this->SetWindowText("采集数据:Qmid");
		}
		else
		{
			this->SetWindowText("采集数据:Qmax");
		}
		m_list.InsertColumn(0, "表号", LVCFMT_LEFT, 60);
		m_list.InsertColumn(1, "次数", LVCFMT_LEFT, 60);
		m_list.InsertColumn(2, "备测表流量", LVCFMT_LEFT, 110);
		m_list.InsertColumn(3, "标准表流量", LVCFMT_LEFT, 110);
		//g_Font = new CFont;       
		//g_Font->CreatePointFont(90, "宋体");
		::EnumChildWindows(m_hWnd, ::SetChildFont, (LPARAM)&g_font);
	}
	else
	{
		if (app->flux.Compare("min") == 0)
		{
			this->SetWindowText("Collect:Qmin");
		}
		else if (app->flux.Compare("mid") == 0)
		{
			this->SetWindowText("Collect:Qmid");
		}
		else
		{
			this->SetWindowText("Collect:Qmax");
		}
		m_list.InsertColumn(0, "IDN", LVCFMT_LEFT, 60);
		m_list.InsertColumn(1, "times", LVCFMT_LEFT, 60);
		m_list.InsertColumn(2, "Meter Reading", LVCFMT_LEFT, 110);
		m_list.InsertColumn(3, "Reference Reading", LVCFMT_LEFT, 110);
		//g_Font = new CFont;       
		//g_Font->CreatePointFont(90, "Times New Roman");
		::EnumChildWindows(m_hWnd, ::SetChildFont, (LPARAM)&g_font);
	}

	//连接数据库
	//m_pAppConn.CreateInstance(__uuidof(Connection));
	//m_pAppConn->Open("File Name=MyData.udl", "", "", adConnectUnspecified);
	db_Setup(app);//temporary database setting up, the meters which can be calibrated will be loaded in CCalibrationApp->Meters[20], with CCalibrationApp->no be the number of total available meters now

	flag = 0;
	Count = 0;
	err_ref_count = 0;

	//if (app->flux.Compare("小") == 0)
	//{
	//UINT_PTR t_M38(SetTimer(2, Sampling_Gap, NULL));

	Sampling_Gap = 1000;
	Sampling_Total = app->Global_Sampling_Total;
	m_pro.SetRange(0,3*Sampling_Total);
	m_pro.SetStep(1);
	SetTimer(1, Sampling_Gap, NULL);
	To_file = true;
	float flows(.0), times(.0);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CCollectDlg::db_Setup(CCalibrationApp *app) {
	try
	{
		HRESULT hr = m_pAppConn.CreateInstance(__uuidof(Connection));
		if (FAILED(hr))
			AfxMessageBox("Can't create an intance of ADO.Connection");

		if (FAILED(m_pAppConn->Open(_bstr_t("File Name=MyData.udl"), _bstr_t(""), _bstr_t(""), adModeUnknown)))
			::AfxMessageBox(TEXT("Can't open datasource"));
		//m_pAppConn->Close();
	}
	catch (_com_error &e)
	{
		::AfxMessageBox(TEXT("Unable to connect MS SQL Server, check MyData.udl"));
		_bstr_t bstrSource(e.Source());
		_bstr_t bstrDescription(e.Description());
		TRACE("Exception thrown for classes generated by #import");
		TRACE("\tCode = %08lx\n", e.Error());
		TRACE("\tCode meaning = %s\n", e.ErrorMessage());
		TRACE("\tSource = %s\n", (LPCTSTR)bstrSource);
		TRACE("\tDescription = %s\n", (LPCTSTR)bstrDescription);
	}
	catch (...)
	{
		TRACE("*** Unhandled Exception ***");
	}

	CString sql;
	sql.Format("USE settings");
	try {
		m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
	}
	catch (...) {
		::AfxMessageBox(TEXT("Unable to connect \'settings\' database "));
	}

	sql.Format("select netword_IDN,s_n from Independent_settings where state=1");
	int m = 0;
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		if (!m_recordset->adoEOF)
		{
			m_recordset->MoveFirst();
		}
		else
		{
			if (app->language == 0)
			{
				AfxMessageBox("没有发现可标定的表!");
			}
			else
			{
				hHook = SetWindowsHookEx(WH_CBT, (HOOKPROC)CBTHookProc, AfxGetInstanceHandle(), NULL);
				AfxMessageBox("during db_Setup: Did not find the meter that can be calibrated!");
			}
			//gl test
			//EndDialog(5);
			//gl test end

		}

		int i(0);
		while (!m_recordset->adoEOF)
		{
			_variant_t var = m_recordset->GetCollect("netword_IDN");
			CString meter = (char *)_bstr_t(var);
			var = m_recordset->GetCollect("s_n");
			CString serielno = (char *)_bstr_t(var);
			int IDN;
			sscanf_s(meter, "%d", &IDN);
			app->Meters[i].IDN = IDN;//write IDN
			app->Meters[i].s_n.Format(serielno);//write serielno
			app->Meters[i].Installed = true;
			app->liuliang[i].mmeter.Format(_T("%d"), IDN);
			i++;
			m_recordset->MoveNext();
		}
		app->no = i;
	}//end try
	catch (...) {
		AfxMessageBox("during db_Setup in catch: Did not find the meter that can be calibrated!");
	}
}

void CCollectDlg::OnTimer(UINT nIDEvent)
{
	// TODO: Add your message handler code here and/or call default
	endflag = 0;
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	SYSTEMTIME st;
	CString strtime;
	GetLocalTime(&st);
	strtime.Format("%04d%02d%02d", st.wYear, st.wMonth, st.wDay);

	int temp, max = 0;
	CString sql;
	sql.Format("SELECT RIGHT(name,3) bh FROM sysobjects WHERE name LIKE \'Data%s%c\'", strtime, '%');
	try
	{
		m_recordset = m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
		if (!m_recordset->adoEOF)
		{
			m_recordset->MoveFirst();
		}
		while (!m_recordset->adoEOF)
		{
			_variant_t var = m_recordset->GetCollect("bh");
			CString bh = (char *)_bstr_t(var);
			sscanf(bh, "%d", &temp);
			if (max < temp)
			{
				max = temp;
			}
			m_recordset->MoveNext();
		}
	}
	catch (_com_error e)
	{
		AfxMessageBox(e.ErrorMessage());
	}

	if (!app->g_com.IsOpen())
	{
		//app->g_com.Open(app->commm, 9600, NOPARITY, 8, ONESTOPBIT);
		app->g_com.Open(app->commm, 9600, NOPARITY, 8, TWOSTOPBITS);
	}
	switch (nIDEvent)
	{
	case 1://YC Note: data collection, set @ OninitDiag func, SetTimer() line
	{
		//YC note: read reference flowrate first;
		int i(0);
		CString flow2;//YC Note: flow of ref meter
		CString FLOW2;

		try {
			Meter_Op::Read_Ref_flowrate(collect2[flag]);
		}
		catch (Meter_err err) {         
			collect2[flag] = -1999;//this collect2 will not be added to final
			err_ref_count++;
			if (err_ref_count == 5) {
				AfxMessageBox(err.err_msg);//report error only when 5 error reading reached;
				KillTimer(1);
				EndDialog(5);
			}
		}

		if (flag == Sampling_Total - 1)
		{
			float s = 0.0;
			for (i = 0; i < Sampling_Total; i++)
			{
				if(collect2[i]!=-1999)s += collect2[i];
			}
			float s1 = s / (float)(Sampling_Total-err_ref_count);
			FLOW2.Format("%f", s1);
			s1 = (int)(s1 * 1000 + 0.5f) / 1000.0f;
			flow2.Format("%.3f", s1);
			err_ref_count = 0;
		}
		if (flag == 2 * Sampling_Total - 1)
		{
			float s = 0.0;
			for (i = Sampling_Total; i < 2 * Sampling_Total; i++)
			{
				if (collect2[i] != -1999)s += collect2[i];
			}
			float s1 = s / (float)(Sampling_Total-err_ref_count);
			FLOW2.Format("%f", s1);
			s1 = (int)(s1 * 1000 + 0.5f) / 1000.0f;
			flow2.Format("%.3f", s1);
			err_ref_count = 0;
		}
		if (flag == 3 * Sampling_Total - 1)
		{
			float s = 0.0;
			for (i = 2 * Sampling_Total; i < 3 * Sampling_Total; i++)
			{
				if (collect2[i] != -1999)s += collect2[i];
			}
			float s1 = s / (float)(Sampling_Total - err_ref_count);
			FLOW2.Format("%f", s1);
			s1 = (int)(s1 * 1000 + 0.5f) / 1000.0f;
			flow2.Format("%.3f", s1);
			err_ref_count = 0;
		}

		//YC note: read each testing meter in a for loop. If an error is thrown, that meter will be bypassed cause Meters[m].Installed=false
		int k(app->no);
		Meter_Info *M = app->Meters;
		for (int m(0); m < k; m++) {
			if (app->Meters[m].Installed != true)continue;//This meter has some problems, jump to next meter
			float fflow(.0), speed(.0);
			float Strength_Quality[3];
			try {
				Meter_Op::Read_FlowByMin(app->Meters[m].IDN, fflow);//Read the flow rate
				Meter_Op::Read_FluidVelocity(app->Meters[m].IDN, speed);//Read speed
				Meter_Op::Read_S_Q(app->Meters[m].IDN, Strength_Quality);//Read signal strength and quality
			}
			catch (Meter_err err) {
				AfxMessageBox(err.err_msg);
				app->Meters[m].Installed = false;
				//hHook = SetWindowsHookEx(WH_CBT, (HOOKPROC)CBTHookProc, AfxGetInstanceHandle(), NULL);
			}

			collect[m][flag] = fflow;
			app->liuliang[m].mflux = fflow;
			app->liuliang[m].mspeed = speed;
			//app->liuliang[m].posTotalf = posTot;
			app->liuliang[m].S_UPf = Strength_Quality[0];
			app->liuliang[m].S_DNf = Strength_Quality[1];
			app->liuliang[m].Qf = Strength_Quality[2];
			app->liuliang[m].unflux = "m3/min";
			app->liuliang[m].unspeed = "m/s";
	//app->liuliang[m].mmeter = app->Meters[m].IDN;

			CString flow;//flow of the testing meter
			CString FLOW;

			float time_passed(.0), flow_passed(.0);

			//Turn on and off the M38 stopwatch totalizer at certain point
			try {
				if (flag == 0) {//turn on stopwatch totalizer for the first time
					Meter_Op::M38_Turn_On(app->Meters[m].IDN);
				}
				else if (flag == Sampling_Total - 1) {//turn off stopwatch totalizer for the first time
					Meter_Op::M38_Turn_Off(app->Meters[m].IDN, time_passed, flow_passed);
					float flow_per_min = flow_passed / time_passed * 60;
					FLOW.Format("%f", flow_per_min);
					flow_per_min = (int)(flow_per_min * 1000 + 0.5f) / 1000.0f;
					flow.Format("%.3f", flow_per_min);
				}
				else if (flag == Sampling_Total) {//second time, turn on
					Meter_Op::M38_Turn_On(app->Meters[m].IDN);
				}
				else if (flag == 2 * Sampling_Total - 1) {//second time, turn off
					Meter_Op::M38_Turn_Off(app->Meters[m].IDN, time_passed, flow_passed);
					float flow_per_min = flow_passed / time_passed * 60;
					FLOW.Format("%f", flow_per_min);
					flow_per_min = (int)(flow_per_min * 1000 + 0.5f) / 1000.0f;
					flow.Format("%.3f", flow_per_min);
				}
				else if (flag == 2 * Sampling_Total) {//third time, turn on
					Meter_Op::M38_Turn_On(app->Meters[m].IDN);
				}
				else if (flag == 3 * Sampling_Total - 1) {//third time, turn off
					Meter_Op::M38_Turn_Off(app->Meters[m].IDN, time_passed, flow_passed);
					float flow_per_min = flow_passed / time_passed * 60;
					FLOW.Format("%f", flow_per_min);
					flow_per_min = (int)(flow_per_min * 1000 + 0.5f) / 1000.0f;
					flow.Format("%.3f", flow_per_min);
				}
			}
			catch (Meter_err err) {
				app->Meters[m].Installed = false;
				AfxMessageBox(err.err_msg);
				KillTimer(1);
				EndDialog(5);
			}
			
			CString sql;
			CString meter("");
			meter.Format(_T("%d"), app->Meters[m].IDN);
			//CCalibrationApp *app = (CCalibrationApp *)AfxGetApp(); //生成指向应用程序类的指针, updating the GUI control list, and the DB
			if (flag == Sampling_Total - 1)
			{
				m_list.InsertItem(Count, meter);
				m_list.SetItemText(Count, 1, "1");
				if ((float)atof((char *)(LPTSTR)(LPCTSTR)flow) == -1)
				{
					m_list.SetItemText(Count, 2, "ERROR");
				}
				else
				{
					m_list.SetItemText(Count, 2, (LPCTSTR)flow);
				}
				if ((float)atof((char *)(LPTSTR)(LPCTSTR)flow2) == -1)
				{
					m_list.SetItemText(Count, 3, "ERROR");
				}
				else
				{
					m_list.SetItemText(Count, 3, (LPCTSTR)flow2);
				}
				sql.Format("USE settings IF NOT EXISTS(SELECT * FROM Data%s%03d WHERE netword_IDN = %s AND s_n=\'%s\' AND flow=\'%s\')INSERT INTO Data%s%03d VALUES(%s,\'%s\',\'%s\',\'%s\',0,0,\'%s\',0,0,0,0,0) else UPDATE Data%s%03d SET flow_1=\'%s\',Rflow_1=\'%s\' WHERE netword_IDN=%s AND s_n=\'%s\' AND flow=\'%s\'", strtime, max, meter, app->Meters[m].s_n, app->flux, strtime, max, meter, app->Meters[m].s_n, app->flux, FLOW, FLOW2, strtime, max, FLOW, FLOW2, meter, app->Meters[m].s_n, app->flux);
				try
				{
					m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
				}
				catch (_com_error e)
				{
					AfxMessageBox(e.ErrorMessage());
				}
				++Count;
			}
			else if (flag == 2 * Sampling_Total - 1)
			{
				m_list.InsertItem(Count, meter);
				m_list.SetItemText(Count, 1, "2");
				if ((float)atof((char *)(LPTSTR)(LPCTSTR)flow) == -1)
				{
					m_list.SetItemText(Count, 2, "ERROR");
				}
				else
				{
					m_list.SetItemText(Count, 2, (LPCTSTR)flow);
				}
				if ((float)atof((char *)(LPTSTR)(LPCTSTR)flow2) == -1)
				{
					m_list.SetItemText(Count, 3, "ERROR");
				}
				else
				{
					m_list.SetItemText(Count, 3, (LPCTSTR)flow2);
				}
				sql.Format("USE settings UPDATE Data%s%03d SET flow_2=\'%s\',Rflow_2=\'%s\' where netword_IDN=%s AND s_n=\'%s\' and flow=\'%s\'", strtime, max, FLOW, FLOW2, meter, app->Meters[m].s_n, app->flux);
				try
				{
					m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
				}
				catch (_com_error e)
				{
					AfxMessageBox(e.ErrorMessage());
				}
				++Count;
			}
			else if (flag == 3 * Sampling_Total - 1)
			{
				m_list.InsertItem(Count, meter);
				m_list.SetItemText(Count, 1, "3");
				if ((float)atof((char *)(LPTSTR)(LPCTSTR)flow) == -1)
				{
					m_list.SetItemText(Count, 2, "ERROR");
				}
				else
				{
					m_list.SetItemText(Count, 2, (LPCTSTR)flow);
				}
				if ((float)atof((char *)(LPTSTR)(LPCTSTR)flow2) == -1)
				{
					m_list.SetItemText(Count, 3, "ERROR");
				}
				else
				{
					m_list.SetItemText(Count, 3, (LPCTSTR)flow2);
				}
				sql.Format("USE settings UPDATE Data%s%03d SET flow_3=\'%s\',Rflow_3=\'%s\' where netword_IDN=%s AND s_n=\'%s\' AND flow=\'%s\'", strtime, max, FLOW, FLOW2, meter, app->Meters[m].s_n, app->flux);
				try
				{
					m_pAppConn->Execute((_bstr_t)sql, NULL, adCmdText);
				}
				catch (_com_error e)
				{
					AfxMessageBox(e.ErrorMessage());
				}
				++Count;

				if (To_file == true) {
					ofstream Logfile;
					CString Logfile_name;
					Logfile_name.Format("logs\\Log_Data%s%03d_%s.txt", strtime, max, meter);
					Logfile.open(Logfile_name, ofstream::out | ofstream::app);
					for (int k(0); k < 3 * Sampling_Total; k++) {
						Logfile << k << "\tIDN:\t" << meter << "\tflow:\t" << collect[m][k] << "\trefer flow:\t" << collect2[k] << endl;
					}
					Logfile.close();
				}
			}
		}//End of for loop, jump to next meter
		++flag;
		if (flag == 3 * Sampling_Total) {
			KillTimer(1);
			EndDialog(0);
		}
		break;
	}
	}
	
	if (nIDEvent == 1)
	{
		int nPrePos = m_pro.StepIt();
	}
	endflag = 1;
	CDialog::OnTimer(nIDEvent);
}

void CCollectDlg::OnClose()
{
	Sleep(1000);
	// TODO: Add your message handler code here and/or call default
	CCalibrationApp *app = (CCalibrationApp *)AfxGetApp();
	KillTimer(1);
	KillTimer(2);
	if (!app->g_com.IsOpen())
	{
		//app->g_com.Open(app->commm, 9600, NOPARITY, 8, ONESTOPBIT);
		app->g_com.Open(app->commm, 9600, NOPARITY, 8, TWOSTOPBITS);
	}
	do
	{
		Sleep(50);
	} while (endflag == 0);

	if (m_recordset)
		if (m_recordset->State == adStateOpen)
			m_recordset->Close();
	if (m_pAppConn)
		if (m_pAppConn->State == adStateOpen)
			m_pAppConn->Close();

	m_pAppConn.Release();

	CDialog::OnClose();
}

void CCollectDlg::OnDestroy()
{
	CDialog::OnDestroy();

	// TODO: Add your message handler code here
	do
	{
		Sleep(50);
	} while (endflag == 0);
}
